-- Question 1: (Index)
-- a.	Write SQL query to return a list of orderlines having “quantity” greater than 2
EXPLAIN
SELECT * FROM orderlines WHERE quantity > 2;

-- b.	Write SQL sentence to create a hash index on orderlines.quantity and show the query plan for query (a) generated by DBMS
DROP INDEX IF EXISTS orderlines_quantity;
CREATE INDEX orderlines_quantity ON orderlines USING HASH (quantity);

-- c.	Write SQL sentence to create a btree index on orderlines.quantity and show the query plan for query (a) generated by DBMS
DROP INDEX IF EXISTS orderlines_quantity;
CREATE INDEX orderlines_quantity ON orderlines USING BTREE (quantity);

-- d.	Is there any difference between the query plans generated in b and c? Explain
-- The index of b wasn't used, while the index of c was used. The index of b is a hash index, which is not suitable for range queries. The index of c is a btree index, which is suitable for range queries.
-- e.	Drop all the index created in (b) and (c). Write SQL query to return a list of orderlines having “quantity” greater than 3 and then redo b, c, d for the new query
EXPLAIN
SELECT * FROM orderlines WHERE quantity > 3;

-- f.	Is there any difference between d and e? Explain
-- Question 2: (Query)
-- a.	Write SQL all possible queries (join, nested queries…) to return a list of different orders having the total number of products greater than 6
SELECT order_id
FROM orderlines
GROUP BY order_id
HAVING SUM(quantity) > 6;

-- b.	Compare the query plans generated by DBMS for the above queries. Are they different? Explain
-- c.	Create relevant index(es) for the above queries and check if index is used. Explain
CREATE INDEX orderlines_order_id ON orderlines (order_id);

-- Question 3 (Trigger)
-- a.	Add the attributes “in_stock” in the relation Product. “in_stock” is the number of product in stock
ALTER TABLE products
ADD COLUMN in_stock INTEGER;

-- b.	Write trigger to ensure that the attribute “in_stock” must be updated (increase/decrease) automatically according to the quantity of the product when new order(lines) are added or existing ones are modified
DROP FUNCTION IF EXISTS update_in_stock();
CREATE FUNCTION update_in_stock()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE products
        SET in_stock = in_stock - NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE products
        SET in_stock = in_stock + OLD.quantity - NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE products
        SET in_stock = in_stock + OLD.quantity
        WHERE id = OLD.product_id;
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS update_in_stock ON orderlines;
CREATE TRIGGER update_in_stock
    AFTER INSERT OR UPDATE OR DELETE
    ON orderlines
    FOR EACH ROW
    EXECUTE PROCEDURE update_in_stock();

-- Question 4: (Function)
-- Write a function to return all product having “in_stock” under a given limit (provided as input argument)
CREATE OR REPLACE FUNCTION get_products_under_limit(limitt INTEGER)
    RETURNS TABLE (prod_id INTEGER, in_stock INTEGER)
    LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT p.prod_id, p.in_stock
    FROM products p
    WHERE p.in_stock < limitt;
END;
$$;

SELECT * FROM get_products_under_limit(100);
